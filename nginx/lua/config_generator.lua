--[[
    config_generator.lua - Generate nginx configs from discovered containers

    Generates upstream and server blocks for each discovered container,
    writes them to /etc/nginx/conf.d/compass/, and reloads nginx.
]]

local docker = require "docker"

local _M = {}

-- Configuration
local CONFIG_DIR = "/etc/nginx/conf.d/compass"
local DEBOUNCE_DELAY = 2  -- seconds
local LOCK_KEY = "regen_lock"
local LOCK_TIMEOUT = 60  -- seconds
local SSL_CERT_PATH = "/certs/cert.pem"
local SSL_KEY_PATH = "/certs/key.pem"

-- Shared state
local regen_scheduled = false
local last_regen_time = 0

-- Check if SSL certificates exist
local function ssl_enabled()
    local cert_file = io.open(SSL_CERT_PATH, "r")
    local key_file = io.open(SSL_KEY_PATH, "r")
    local enabled = cert_file ~= nil and key_file ~= nil
    if cert_file then cert_file:close() end
    if key_file then key_file:close() end
    return enabled
end

-- Sanitize hostname for use as filename
local function sanitize_filename(hostname)
    return hostname:gsub("[^%w%.%-]", "_")
end

-- Sanitize container name for use as upstream name
local function sanitize_upstream_name(name)
    return name:gsub("[^%w]", "_")
end

-- Generate server block template for a container
local function generate_server_config(container)
    local upstream_name = "upstream_" .. sanitize_upstream_name(container.name)
    local has_ssl = ssl_enabled()

    -- SSL server block (if certificates available)
    local ssl_block = ""
    if has_ssl then
        ssl_block = string.format([[

server {
    listen 443 ssl;
    server_name %s;

    # SSL configuration
    ssl_certificate %s;
    ssl_certificate_key %s;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;

    # Large file support
    client_max_body_size 20G;
    chunked_transfer_encoding on;
    client_body_buffer_size 10M;
    client_body_temp_path /tmp/nginx/client_temp 1 2;

    # Timeouts
    client_body_timeout 300s;
    client_header_timeout 300s;
    keepalive_timeout 300s;
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    location / {
        proxy_pass http://%s;
        proxy_http_version 1.1;

        # Proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Buffering settings for large responses
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Error handling
        proxy_intercept_errors on;
        error_page 502 = @backend_down;
        error_page 504 = @backend_timeout;
    }

    # Error: backend unreachable
    location @backend_down {
        default_type application/json;
        return 502 '{"error":"Backend server is unreachable","code":"BACKEND_DOWN","service":"%s"}';
    }

    # Error: backend timeout
    location @backend_timeout {
        default_type application/json;
        return 504 '{"error":"Backend server timed out","code":"BACKEND_TIMEOUT","service":"%s"}';
    }
}
]], container.hostname, SSL_CERT_PATH, SSL_KEY_PATH, upstream_name, container.hostname, container.hostname)
    end

    local config = string.format([[
# Auto-generated by compass for container: %s
# Hostname: %s
# SSL: %s

upstream %s {
    server %s:%d;
    keepalive 32;
}

server {
    listen 80;
    server_name %s;

    # Large file support
    client_max_body_size 20G;
    chunked_transfer_encoding on;
    client_body_buffer_size 10M;
    client_body_temp_path /tmp/nginx/client_temp 1 2;

    # Timeouts
    client_body_timeout 300s;
    client_header_timeout 300s;
    keepalive_timeout 300s;
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    location / {
        proxy_pass http://%s;
        proxy_http_version 1.1;

        # Proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;

        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Buffering settings for large responses
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Error handling
        proxy_intercept_errors on;
        error_page 502 = @backend_down;
        error_page 504 = @backend_timeout;
    }

    # Error: backend unreachable
    location @backend_down {
        default_type application/json;
        return 502 '{"error":"Backend server is unreachable","code":"BACKEND_DOWN","service":"%s"}';
    }

    # Error: backend timeout
    location @backend_timeout {
        default_type application/json;
        return 504 '{"error":"Backend server timed out","code":"BACKEND_TIMEOUT","service":"%s"}';
    }
}
]] .. ssl_block,
        container.name,
        container.hostname,
        has_ssl and "enabled" or "disabled",
        upstream_name,
        container.ip,
        container.port,
        container.hostname,
        upstream_name,
        container.hostname,
        container.hostname
    )

    return config
end

-- Write config file
local function write_config(filename, content)
    local filepath = CONFIG_DIR .. "/" .. filename
    local file, err = io.open(filepath, "w")
    if not file then
        ngx.log(ngx.ERR, "compass: failed to open config file for writing: ", filepath, " - ", err)
        return false, err
    end

    file:write(content)
    file:close()

    ngx.log(ngx.INFO, "compass: wrote config file: ", filepath)
    return true, nil
end

-- List existing config files
local function list_config_files()
    local files = {}
    local handle = io.popen("ls -1 " .. CONFIG_DIR .. "/*.conf 2>/dev/null")
    if handle then
        for line in handle:lines() do
            local filename = line:match("([^/]+)$")
            if filename then
                files[filename] = true
            end
        end
        handle:close()
    end
    return files
end

-- Delete config file
local function delete_config(filename)
    local filepath = CONFIG_DIR .. "/" .. filename
    local ok, err = os.remove(filepath)
    if ok then
        ngx.log(ngx.INFO, "compass: removed orphaned config: ", filepath)
    else
        ngx.log(ngx.WARN, "compass: failed to remove config: ", filepath, " - ", err)
    end
    return ok
end

-- Read master process PID from pid file
local function get_master_pid()
    local file = io.open("/usr/local/openresty/nginx/logs/nginx.pid", "r")
    if not file then
        return nil
    end
    local pid = file:read("*l")
    file:close()
    return pid and tonumber(pid)
end

-- Skip config test (run as worker, can't test)
-- We trust our generated configs are valid
local function test_config()
    return true, nil
end

-- Reload nginx by sending HUP signal to master process
local function reload_nginx()
    local master_pid = get_master_pid()
    if not master_pid then
        ngx.log(ngx.WARN, "compass: could not read master PID, skipping reload")
        return true, nil  -- Return success but don't reload
    end

    -- Try using os.execute with SIGHUP
    local cmd = string.format("kill -HUP %d 2>&1", master_pid)
    local handle = io.popen(cmd)
    if not handle then
        ngx.log(ngx.WARN, "compass: could not execute reload command")
        return true, nil  -- Return success, configs are written
    end

    local output = handle:read("*a")
    local ok, _, code = handle:close()

    if code == 0 then
        ngx.log(ngx.INFO, "compass: nginx reload signal sent to PID ", master_pid)
        return true, nil
    else
        -- If signal fails, just log and continue - configs are written
        ngx.log(ngx.WARN, "compass: nginx reload signal failed (configs written, restart to apply): ", output)
        return true, nil  -- Return success anyway
    end
end

-- Try to acquire lock
local function acquire_lock()
    local lock = ngx.shared.regen_lock
    if not lock then
        -- No shared dict available (maybe during startup), proceed anyway
        return true
    end

    local ok, err = lock:add(LOCK_KEY, true, LOCK_TIMEOUT)
    if ok then
        return true
    end

    if err == "exists" then
        ngx.log(ngx.INFO, "compass: regeneration already in progress, skipping")
        return false
    end

    ngx.log(ngx.WARN, "compass: failed to acquire lock: ", err)
    return false
end

-- Release lock
local function release_lock()
    local lock = ngx.shared.regen_lock
    if lock then
        lock:delete(LOCK_KEY)
    end
end

-- Main regeneration function
function _M.regenerate()
    -- Try to acquire lock
    if not acquire_lock() then
        return false, "lock not acquired"
    end

    ngx.log(ngx.INFO, "compass: starting config regeneration")

    local ok, result = pcall(function()
        -- Get list of containers
        local containers, err = docker.list_compass_containers()
        if not containers then
            ngx.log(ngx.ERR, "compass: failed to list containers: ", err)
            return false, err
        end

        ngx.log(ngx.INFO, "compass: discovered ", #containers, " containers with compass labels")

        -- Track which config files we're generating
        local generated_files = {}

        -- Generate configs for each container
        for _, container in ipairs(containers) do
            local filename = sanitize_filename(container.hostname) .. ".conf"
            local config = generate_server_config(container)
            local ok, err = write_config(filename, config)
            if ok then
                generated_files[filename] = true
            end
        end

        -- Remove orphaned config files
        local existing_files = list_config_files()
        for filename, _ in pairs(existing_files) do
            if not generated_files[filename] then
                delete_config(filename)
            end
        end

        -- Test configuration
        local test_ok, test_err = test_config()
        if not test_ok then
            ngx.log(ngx.ERR, "compass: config test failed: ", test_err)
            return false, "config test failed: " .. (test_err or "unknown error")
        end

        -- Reload nginx
        local reload_ok, reload_err = reload_nginx()
        if not reload_ok then
            return false, "reload failed: " .. (reload_err or "unknown error")
        end

        last_regen_time = ngx.now()
        return true, nil
    end)

    release_lock()

    if not ok then
        ngx.log(ngx.ERR, "compass: regeneration error: ", result)
        return false, result
    end

    return result
end

-- Schedule a debounced regeneration
function _M.schedule_regeneration()
    if regen_scheduled then
        ngx.log(ngx.DEBUG, "compass: regeneration already scheduled, skipping")
        return
    end

    regen_scheduled = true

    local ok, err = ngx.timer.at(DEBOUNCE_DELAY, function(premature)
        regen_scheduled = false

        if premature then
            return
        end

        _M.regenerate()
    end)

    if not ok then
        regen_scheduled = false
        ngx.log(ngx.ERR, "compass: failed to schedule regeneration: ", err)
    else
        ngx.log(ngx.INFO, "compass: regeneration scheduled in ", DEBOUNCE_DELAY, "s")
    end
end

return _M
